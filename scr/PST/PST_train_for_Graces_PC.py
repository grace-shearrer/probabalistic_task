#!/usr/bin/python

#fMRI PST training script.
#Last Updated: Sep 8, 2022
#Last updated by Yana Oct 6
#Original Author: Dan Dillon
#Updated by: G Shearrer and Y Akmadjonova
#for the serial library, download pyserial (not serial)
#ports differ on different pc-s
#datapath may need updating on another pc

import os
from math import floor
import numpy as np
import pandas as pd
from psychopy import core, data, event, gui, misc, sound, visual
import serial
from PST_functions import check_rand, show_resp, show_fdbk, set_visuals, show_fix, stimulating, make_it, block_it, stim_mapping, intro, starter, present_stims
from PST_setup import *

# don't forget to check the port in device manager (associated with cp210 driver)
# ser = serial.Serial('COM4', 9800)

wintype='pyglet' 

#to make it run on every pc
cwd = os.getcwd()
stimpath = (cwd + r"\PST_Py_Stims")

#Screen refresh duration.

refresh = 16.7

#Basic parameters.

num_disdaqs = 5 # not sure what this is yet

TR = 3 #Shouldn't need not scanning

initial_waittime = 5
stim_dur = 3
fdbk_dur = 1
disdaq_time = int(15) #15s (5TRs) math.floor rounds to nearest int
num_trials = 60 #Per block.
trial_dur = 8 #On average.
lastHRF = 15 #Time in sec, adjusted on-fly to account for timing errors.

end_time = (TR * num_disdaqs) + (num_trials * trial_dur) + lastHRF

#Define response keys.

left_key = '1'
right_key = '4'
quit_key = 'q'


##GUI to get subject number, date.
info = {}

info['fullscr'] = False
info['test?'] = False
#info['port'] = '/dev/tty.usbserial'
info['participant'] = 'test'
#info['run']='run01'
info['Bluetooth'] = False
info['computer']= 'enter computer name here'
#info['Com_port']
info['dateStr'] = data.getDateStr()
#if info['Bluetooth'] == False:
#    ser = serial.Serial(info['Com_port'], 9600, write_timeout = 3)

dlg = gui.DlgFromDict(info)

if dlg.OK:
    misc.toFile('PST_fMRI_lastParams.pickle', info) 
else:
    core.quit()
#/Users/gracer/Library/CloudStorage/OneDrive-SharedLibraries-UniversityofWyoming/M2AENAD Lab - Documents/RESEARCH/GRRL/PST
stimpath = './Stims/'
if os.path.exists(os.path.join('.','Datapath')):
    print('got datapath')
else:
    mkdir(os.path.join('.','Datapath'))

datapath = os.path.join('.','Datapath')

parameters = set_visuals([600,400], False, 'MacAir', 'black', wintype, 'Text', 'center', 0.12, 350, 'white', 0.3, stimpath)
#Global_variables
win = parameters['win']
instruct = parameters['instruct']
left_choice = parameters['left_choice']
right_choice = parameters['right_choice']
reward = parameters['reward']
zero = parameters['zero']
no_resp = parameters['no_resp']
fix = parameters['fix']

#Durations (s) for ISI and ITI
#fix_list was generated by random selection from an exponential distribution.
#min = 0.5, max = 8.0, mean = 2.0, mode = 0.5
#train_file = info['participant'] + '_' + info['dateStr']

train_file = os.path.join(datapath, '%s_%s_PST_fMRI_train.csv'%(info['participant'], info['dateStr']))
trainFile = open(train_file, 'w')
trainFile.write('block,trial_num,left_stim,left_stim_number,right_stim,right_stim_number,object_onset,object_duration,response,response_onset,trial_RT,accuracy,isi_onset,isi_duration,scheduled_outcome,feedback,feedback_onset,feedback_duration,iti_onset,iti_duration\n')

#fix_list = [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0, 5.0, 5.0, 5.0, 6.0, 6.0, 6.0, 7.0, 8.0]

fix_duration = 1
#Create isi/iti lists w/durations in screen refreshs, and randomize them.

#isi_list = []
#iti_list = []
#
#for dur in range(len(fix_list)):
#    for list in [isi_list, iti_list]:
#        list.append(int(round((fix_list[dur]*1000)/refresh)))

##Set-up the stim/response contingencies.

num_blocks = 4
num_stims = 6
trials_per_stim = 10 # Number times stim on left out of 20 trials.
total_trials = trials_per_stim*num_stims
#Make master list of stim lists.

stim_names = stimulating(num_stims, trials_per_stim)
AB_trialList, CD_trialList, EF_trialList = make_it(stim_names)
small_blocks = block_it(AB_trialList, CD_trialList, EF_trialList)

#Shuffle bitmaps so images used as stims A, B, C, etc. vary across subjects.
pic_list = [os.path.join(stimpath,'1.bmp'), os.path.join(stimpath,'2.bmp'), os.path.join(stimpath,'3.bmp'), os.path.join(stimpath,'4.bmp'), os.path.join(stimpath,'5.bmp'), os.path.join(stimpath,'6.bmp')]

stim_rand = stim_mapping(pic_list, datapath, info['participant'])

#stim_A = pic_list[0]
#stim_C = pic_list[1]
#stim_E = pic_list[2]
#stim_F = pic_list[3]
#stim_D = pic_list[4]
#stim_B = pic_list[5]
#
#Write out stim randomization for use in test.

#Clocks.

RT = core.Clock()
task_clock = core.Clock()

#File to collect training data. 


##Start the study.

inst_text = [
'This is a new game, with\nchances to win more money.\n\nPress button 1 to advance.', 
'Two figures will appear\non the computer screen.\n\nOne figure will pay you more often\nthan the other, but at first you won\'t\nknow which figure is the good one.\n\nPress 1 to advance.', 
'Try to pick the figure that pays\nyou most often.\n\nWhen you see the REWARD screen,\nthat means you won bonus money!\n\nWhen you see the ZERO screen,\nyou did not win.\n\nPress 1 to advance.', 
'Keep in mind that no figure\npays you every time you pick it.\n\nJust try to pick the one\nthat pays most often.\n\nPress 1 to select the figure\non the left. Press 4 to select\nthe figure on the right.\n\nPress 1 to advance.', 
'At first you may be confused,\nbut don\'t worry.\n\nYou\'ll get plenty of chances.\n\nPress 1 to advance.', 
'There are 4 blocks of trials.\nEach one lasts about 8 minutes.\n\nMake sure to try all the figures\nso you can learn which ones\nare better and worse.\n\nPress button 1 to advance.']

allKeys = []

# Introduction    
intro(inst_text, instruct, win, allKeys, left_key, quit_key)

#Run experimental trials.
for block_num, block in enumerate(range(num_blocks)):    
    #Check-in before starting scan.
    #stim_matrix[i] = (left_stim,left_stim_name,left_stim_number,right_stim,right_stim_name,right_stim_number,scheduled_outcome)
 
    stim_matrix = starter(small_blocks, stim_rand, win)
    last_text = ['Ready to begin, press o when you are comfortable']

    advance = 'false'
    k = ['']

    while advance == 'false':
        instruct.setText(text=last_text[0])
        instruct.draw()
        win.flip()
        k = event.waitKeys()

        if k[0] == 'o':
            advance = 'true'

        elif k[0] == 'q':
            core.quit()
    fix.draw()
    win.flip()
    
    #Run through the trials.

    for i in range(total_trials):

        trial_num = i + 1

        #Clear buffers.

        event.clearEvents()
        allKeys=[]
        resp=[]
        trial_RT=[]
        stim_frameN = 0

        #Prep the stims.

        left_stim = stim_matrix[trial_num-1][0]
        left_stim_name = stim_matrix[trial_num-1][1]
        left_stim_number = stim_matrix[trial_num-1][2]
        right_stim = stim_matrix[trial_num-1][3]
        right_stim_name = stim_matrix[trial_num-1][4]
        right_stim_number = stim_matrix[trial_num-1][5]
        scheduled_outcome = stim_matrix[trial_num-1][6]

        #Set ISI/ITI durs.

#        isi_dur = isi_list[i]
#        iti_dur = iti_list[i]

        #Reset the RT clock. 

        RT.reset()
        present_stims(fix,left_stim, right_stim, win, left_key,right_key,quit_key, RT, task_clock)

        #Set-up desired trial dur (excluding ITI).

#        targ_trial_dur = stim_dur + (isi_dur * refresh)/1000 + fdbk_dur

        #Draw the stims and handle keyboard input.
        
#        object_onset = task_clock.getTime()
#        allKeys=event.getKeys(keyList = [left_key,right_key,quit_key], timeStamped=RT)
#        fix.draw()
#        win.flip()
#        while stim_frameN < int(floor(3000/refresh)):
#            response = 'false'
#            left_stim.draw()
#            right_stim.draw()
#            fix.draw()
#            win.flip()
#            allKeys=event.getKeys(keyList = [left_key,right_key,quit_key], timeStamped=RT)

#            if allKeys:
#                resp = allKeys[0][0]
#                trial_RT=allKeys[0][1]
#                #advance_sound.play()
#
#                if resp == quit_key:
#                    core.quit()
#
#                elif resp == left_key:
#                    response = 'left'
#                    trial_response = show_resp(response,left_stim_number,right_stim_number,stim_frameN,refresh,task_clock.getTime(), left_stim, right_stim, fix, win, left_choice, right_choice)
#                    isi = show_fix(isi_dur,task_clock.getTime(),refresh, fix, win)
#                    object_dur = isi[0] - object_onset
#                    feedback = show_fdbk(trial_response[0],scheduled_outcome,task_clock.getTime(),refresh, no_resp, zero,win, reward, info['test?'])
#                    act_trial_dur = object_dur + isi[1] + feedback[2]
#                    iti_dur = iti_dur + int(round(((targ_trial_dur - act_trial_dur)*1000)/refresh))
#                    iti = show_fix(iti_dur,task_clock.getTime(),refresh, fix, win)
#                    stim_frameN = int(floor(3000/refresh))
#
#                elif resp == right_key:
#                    response = 'right'
#                    trial_response = show_resp(response,left_stim_number,right_stim_number,stim_frameN,refresh,task_clock.getTime(), left_stim, right_stim, fix, win, left_choice, right_choice)
#                    isi = show_fix(isi_dur,task_clock.getTime(),refresh, fix, win)
#                    object_dur = isi[0] - object_onset
#                    feedback = show_fdbk(trial_response[0],scheduled_outcome,task_clock.getTime(),refresh, no_resp, zero,win, reward, info['test?'])
#                    act_trial_dur = object_dur + isi[1] + feedback[2]
#                    iti_dur = iti_dur + int(round(((targ_trial_dur - act_trial_dur)*1000)/refresh))
#                    iti = show_fix(iti_dur,task_clock.getTime(),refresh, fix, win)
#                    stim_frameN = int(floor(3000/refresh))
#            
#            stim_frameN = stim_frameN + 1

        #Catch trials with no response.

        if stim_frameN == int(floor(3000/refresh)) and response == 'false':
            response = 'No_response'
            trial_RT = 999
            accuracy = 999
            isi = show_fix(isi_dur,task_clock.getTime(),refresh, fix, win)
            object_dur = isi[0] - object_onset
            trial_response = (999,999.0)
            feedback = show_fdbk(accuracy,scheduled_outcome,task_clock.getTime(),refresh, no_resp, zero,win, reward, info['test?'])
            act_trial_dur = object_dur + isi[1] + feedback[2]
            iti_dur = iti_dur + int(round(((targ_trial_dur - act_trial_dur)*1000)/refresh))
            iti = show_fix(iti_dur,task_clock.getTime(),refresh, fix, win)

        #Write out the data.

#        trainFile.write('%i,%i,%s,%i,%s,%i,%0.3f,%0.3f,%s,%0.3f,%0.3f,%i,%0.3f,%0.3f,%i,%s,%0.3f,%0.3f,%0.3f,%0.3f\n' %(block_num, trial_num, left_stim_name, left_stim_number, right_stim_name, right_stim_number, object_onset, object_dur, response, trial_response[1], trial_RT, trial_response[0], isi[0], isi[1], scheduled_outcome, feedback[0], feedback[1], feedback[2], iti[0], iti[1]))

        #Fade out with lastHRF fixation cross after 60 trials.
        
        if trial_num == 60: 
            elapsed_time = task_clock.getTime()
            time_left = end_time - elapsed_time

            for i in range(int(round((time_left*1000)/refresh))):
                fix.draw()
                win.flip()

    #Present a screen between blocks.

    if block_num < num_blocks:

        pause_text = ['Great job!\n\nYou are done with that block.\n\nTake a few seconds to relax.\n\nWhen you are ready to continue,\npress button 1.']
        
        allKeys = []

        for i in range(len(pause_text)):
            advance = 'false'
            instruct.setText(text = pause_text[i]) 
            
            while advance == 'false':
                instruct.draw()
                win.flip()
                allKeys = event.waitKeys(keyList = [left_key,quit_key])
                resp = allKeys[0][0]

                if resp == left_key:
                    advance = 'true'
                    #advance_sound.play()
                    allKeys = []

                elif resp == quit_key:
                    core.quit()

   

#Now that we've looped over all the blocks, close the training file.

trainFile.close()



#Close the rating file.

PST_Rate_Data_File.close()